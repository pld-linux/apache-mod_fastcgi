diff -urN mod_fastcgi-2.4.2.org/fcgi_config.c mod_fastcgi-2.4.2/fcgi_config.c
--- mod_fastcgi-2.4.2.org/fcgi_config.c	2004-10-06 20:30:46.336894330 +0200
+++ mod_fastcgi-2.4.2/fcgi_config.c	2004-10-06 20:47:33.355164283 +0200
@@ -191,7 +191,7 @@
     const char **header;
 
     if (!*array) {
-        *array = ap_make_array(p, 10, sizeof(char*));
+        *array = apr_make_array(p, 10, sizeof(char*));
     }
 
     header = (const char **)ap_push_array(*array);
@@ -419,7 +419,7 @@
 
         dp = ap_popendir(tp, fcgi_dynamic_dir);
         if (dp == NULL) {
-            ap_destroy_pool(tp);
+            apr_destroy_pool(tp);
             return ap_psprintf(p, "can't open dynamic directory \"%s\": %s",
                 fcgi_dynamic_dir, strerror(errno));
         }
@@ -437,7 +437,7 @@
 
 #endif /* !APACHE2 */
 
-    ap_destroy_pool(tp);
+    apr_destroy_pool(tp);
 
     return NULL;
 }
diff -urN mod_fastcgi-2.4.2.org/fcgi_pm.c mod_fastcgi-2.4.2/fcgi_pm.c
--- mod_fastcgi-2.4.2.org/fcgi_pm.c	2004-10-06 20:30:46.337894116 +0200
+++ mod_fastcgi-2.4.2/fcgi_pm.c	2004-10-06 20:47:33.365162141 +0200
@@ -576,7 +576,7 @@
         fs->envp[i - 1] = NULL;
     }
 
-    ap_destroy_pool(tp);
+    apr_destroy_pool(tp);
 
     return proc.pid;
 
@@ -659,7 +659,7 @@
             "FastCGI: %s is not executable; ensure interpreted scripts have "
             "\"#!\" as their first line", 
             fs->fs_path);
-        ap_destroy_pool(tp);
+        apr_destroy_pool(tp);
         goto CLEANUP;
     }
 
@@ -744,7 +744,7 @@
         CloseHandle(listen_handle);
     }
 
-    ap_destroy_pool(tp);
+    apr_destroy_pool(tp);
 
     return pid;
 
@@ -1340,7 +1340,7 @@
         continue;
 
 BagNewServer:
-        if (sp) ap_destroy_pool(sp);
+        if (sp) apr_destroy_pool(sp);
 
 #ifdef WIN32
     free(cjob->fs_path);
@@ -1362,7 +1362,7 @@
     }
 #endif
 
-    ap_destroy_pool(tp);
+    apr_destroy_pool(tp);
 }
 
 /*
diff -urN mod_fastcgi-2.4.2.org/fcgi_protocol.c mod_fastcgi-2.4.2/fcgi_protocol.c
--- mod_fastcgi-2.4.2.org/fcgi_protocol.c	2004-10-06 20:30:46.338893902 +0200
+++ mod_fastcgi-2.4.2/fcgi_protocol.c	2004-10-06 20:47:33.368161499 +0200
@@ -178,7 +178,7 @@
         int i = ph->nelts;
 
         for ( ; i; --i, ++elt) {
-            const char *val = ap_table_get(fr->r->headers_in, *elt);
+            const char *val = apr_table_get(fr->r->headers_in, *elt);
             if (val) {
                 ap_table_setn(fr->r->subprocess_env, *elt, val);
             }
@@ -373,7 +373,7 @@
 
                 if (fr->fs_stderr == NULL)
                 {
-                    fr->fs_stderr = ap_palloc(p, FCGI_SERVER_MAX_STDERR_LINE_LEN + 1);
+                    fr->fs_stderr = apr_palloc(p, FCGI_SERVER_MAX_STDERR_LINE_LEN + 1);
                 }
 
                 /* We're gonna consume all thats here */
diff -urN mod_fastcgi-2.4.2.org/fcgi_util.c mod_fastcgi-2.4.2/fcgi_util.c
--- mod_fastcgi-2.4.2.org/fcgi_util.c	2004-10-06 20:30:46.339893687 +0200
+++ mod_fastcgi-2.4.2/fcgi_util.c	2004-10-06 20:47:33.372160642 +0200
@@ -367,7 +367,7 @@
     const char *err;
 
     if (finfo == NULL) {
-        finfo = (struct stat *)ap_palloc(p, sizeof(struct stat));	        
+        finfo = (struct stat *)apr_palloc(p, sizeof(struct stat));	        
         if (stat(fs_path, finfo) < 0)
             return ap_psprintf(p, "stat(%s) failed: %s", fs_path, strerror(errno));
     }
diff -urN mod_fastcgi-2.4.2.org/mod_fastcgi.c mod_fastcgi-2.4.2/mod_fastcgi.c
--- mod_fastcgi-2.4.2.org/mod_fastcgi.c	2004-10-06 20:30:46.355890260 +0200
+++ mod_fastcgi-2.4.2/mod_fastcgi.c	2004-10-06 20:47:33.386157643 +0200
@@ -267,7 +267,7 @@
 
     /* Register to reset to default values when the config pool is cleaned */
     ap_block_alarms();
-    ap_register_cleanup(p, NULL, fcgi_config_reset_globals, ap_null_cleanup);
+    ap_register_cleanup(p, NULL, fcgi_config_reset_globals, apr_pool_cleanup_null);
     ap_unblock_alarms();
 
 #ifdef APACHE2
@@ -765,7 +765,7 @@
      * Who responds, this handler or Apache?
      */
     if (hasLocation) {
-        const char *location = ap_table_get(r->headers_out, "Location");
+        const char *location = apr_table_get(r->headers_out, "Location");
         /*
          * Based on internal redirect handling in mod_cgi.c...
          *
@@ -2318,7 +2318,7 @@
     }
 
     ap_block_alarms();
-    ap_register_cleanup(rp, (void *)fr, cleanup, ap_null_cleanup);
+    ap_register_cleanup(rp, (void *)fr, cleanup, apr_pool_cleanup_null);
     ap_unblock_alarms();
 
 #ifdef WIN32
@@ -2450,7 +2450,7 @@
         else
 #endif
         {
-            my_finfo = (struct stat *) ap_palloc(p, sizeof(struct stat));
+            my_finfo = (struct stat *) apr_palloc(p, sizeof(struct stat));
             
             if (stat(fs_path, my_finfo) < 0) 
             {
@@ -2476,7 +2476,7 @@
     fr->erBufPtr = fcgi_buf_new(p, sizeof(FCGI_EndRequestBody) + 1);
     fr->gotHeader = FALSE;
     fr->parseHeader = SCAN_CGI_READING_HEADERS;
-    fr->header = ap_make_array(p, 1, 1);
+    fr->header = apr_make_array(p, 1, 1);
     fr->fs_stderr = NULL;
     fr->r = r;
     fr->readingEndRequestBody = FALSE;
@@ -2531,7 +2531,7 @@
  */
 static int apache_is_scriptaliased(request_rec *r)
 {
-    const char *t = ap_table_get(r->notes, "alias-forced-type");
+    const char *t = apr_table_get(r->notes, "alias-forced-type");
     return t && (!strcasecmp(t, "cgi-script"));
 }
 
@@ -2556,7 +2556,7 @@
             r->method_number = M_GET;
             ap_table_unset(r->headers_in, "Content-length");
 
-            ap_internal_redirect_handler(ap_table_get(r->headers_out, "Location"), r);
+            ap_internal_redirect_handler(apr_table_get(r->headers_out, "Location"), r);
             return OK;
 
         case SCAN_CGI_SRV_REDIRECT:
@@ -2639,16 +2639,16 @@
 
     if (passed) {
         if (fr->auth_compat) {
-            ap_table_do((int (*)(void *, const char *, const char *))post_process_auth_passed_compat_header,
+            apr_table_do((int (*)(void *, const char *, const char *))post_process_auth_passed_compat_header,
                  (void *)r->subprocess_env, fr->authHeaders, NULL);
         }
         else {
-            ap_table_do((int (*)(void *, const char *, const char *))post_process_auth_passed_header,
+            apr_table_do((int (*)(void *, const char *, const char *))post_process_auth_passed_header,
                  (void *)r->subprocess_env, fr->authHeaders, NULL);
         }
     }
     else {
-        ap_table_do((int (*)(void *, const char *, const char *))post_process_auth_failed_header,
+        apr_table_do((int (*)(void *, const char *, const char *))post_process_auth_failed_header,
              (void *)r->err_headers_out, fr->authHeaders, NULL);
     }
 
@@ -2697,7 +2697,7 @@
     post_process_auth(fr, authenticated);
 
     /* A redirect shouldn't be allowed during the authentication phase */
-    if (ap_table_get(r->headers_out, "Location") != NULL) {
+    if (apr_table_get(r->headers_out, "Location") != NULL) {
         ap_log_rerror(FCGI_LOG_ERR_NOERRNO, r,
             "FastCGI: FastCgiAuthenticator \"%s\" redirected (not allowed)",
             dir_config->authenticator);
@@ -2762,7 +2762,7 @@
     post_process_auth(fr, authorized);
 
     /* A redirect shouldn't be allowed during the authorization phase */
-    if (ap_table_get(r->headers_out, "Location") != NULL) {
+    if (apr_table_get(r->headers_out, "Location") != NULL) {
         ap_log_rerror(FCGI_LOG_ERR_NOERRNO, r,
             "FastCGI: FastCgiAuthorizer \"%s\" redirected (not allowed)",
             dir_config->authorizer);
@@ -2823,7 +2823,7 @@
     post_process_auth(fr, access_allowed);
 
     /* A redirect shouldn't be allowed during the access check phase */
-    if (ap_table_get(r->headers_out, "Location") != NULL) {
+    if (apr_table_get(r->headers_out, "Location") != NULL) {
         ap_log_rerror(FCGI_LOG_ERR_NOERRNO, r,
             "FastCGI: FastCgiAccessChecker \"%s\" redirected (not allowed)",
             dir_config->access_checker);
