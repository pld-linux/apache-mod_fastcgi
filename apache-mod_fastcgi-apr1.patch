diff -urN mod_fastcgi-2.4.2.org/fcgi_config.c mod_fastcgi-2.4.2/fcgi_config.c
--- mod_fastcgi-2.4.2.org/fcgi_config.c	2004-10-06 20:30:46.336894330 +0200
+++ mod_fastcgi-2.4.2/fcgi_config.c	2004-10-06 21:33:50.361255856 +0200
@@ -50,7 +50,7 @@
     /* Convert port number */
     tmp = (u_short) strtol(portStr, &cvptr, 10);
     if (*cvptr != '\0' || tmp < 1 || tmp > USHRT_MAX)
-        return ap_pstrcat(p, "bad port number \"", portStr, "\"", NULL);
+        return apr_pstrcat(p, "bad port number \"", portStr, "\"", NULL);
 
     *port = (unsigned short) tmp;
 
@@ -75,7 +75,7 @@
     tmp = strtol(txt, &ptr, 10);
 
     if (*ptr != '\0') {
-        return ap_pstrcat(p, "\"", txt, "\" must be a positive integer", NULL);
+        return apr_pstrcat(p, "\"", txt, "\" must be a positive integer", NULL);
 	}
     
 	if (tmp < min || tmp > USHRT_MAX) {
@@ -101,7 +101,7 @@
 
     if (*cp != '\0')
     {
-        return ap_pstrcat(p, "can't parse ", "\"", val, "\"", NULL);
+        return apr_pstrcat(p, "can't parse ", "\"", val, "\"", NULL);
     }
     else if (*num < min)
     {
@@ -126,7 +126,7 @@
     *num = (u_int)strtol(val, &ptr, 10);
 
     if (*ptr != '\0')
-        return ap_pstrcat(p, "\"", val, "\" must be a positive integer", NULL);
+        return apr_pstrcat(p, "\"", val, "\" must be a positive integer", NULL);
     else if (*num < min)
         return ap_psprintf(p, "\"%u\" must be >= %u", *num, min);
     return NULL;
@@ -147,7 +147,7 @@
     *num = (float) strtod(val, &ptr);
 
     if (*ptr != '\0')
-        return ap_pstrcat(p, "\"", val, "\" is not a floating point number", NULL);
+        return apr_pstrcat(p, "\"", val, "\" is not a floating point number", NULL);
     if (*num < min || *num > max)
         return ap_psprintf(p, "\"%f\" is not between %f and %f", *num, min, max);
     return NULL;
@@ -160,7 +160,7 @@
     }
 
     if (strchr(var, '=') == NULL) {
-        *(envp + *envc) = ap_pstrcat(p, var, "=", getenv(var), NULL);
+        *(envp + *envc) = apr_pstrcat(p, var, "=", getenv(var), NULL);
     }
     else {
         *(envp + *envc) = var;
@@ -191,7 +191,7 @@
     const char **header;
 
     if (!*array) {
-        *array = ap_make_array(p, 10, sizeof(char*));
+        *array = apr_array_make(p, 10, sizeof(char*));
     }
 
     header = (const char **)ap_push_array(*array);
@@ -379,7 +379,7 @@
     const char *err;
     pool *tp;
 
-    fcgi_dynamic_dir = ap_pstrcat(p, fcgi_socket_dir, "/dynamic", NULL);
+    fcgi_dynamic_dir = apr_pstrcat(p, fcgi_socket_dir, "/dynamic", NULL);
 
     if ((err = fcgi_config_make_dir(p, fcgi_dynamic_dir)))
         return ap_psprintf(p, "can't create dynamic directory \"%s\": %s", fcgi_dynamic_dir, err);
@@ -419,7 +419,7 @@
 
         dp = ap_popendir(tp, fcgi_dynamic_dir);
         if (dp == NULL) {
-            ap_destroy_pool(tp);
+            apr_destroy_pool(tp);
             return ap_psprintf(p, "can't open dynamic directory \"%s\": %s",
                 fcgi_dynamic_dir, strerror(errno));
         }
@@ -431,13 +431,13 @@
             if (strcmp(dirp->d_name, ".") == 0 || strcmp(dirp->d_name, "..") == 0)
                 continue;
 
-            unlink(ap_pstrcat(tp, fcgi_dynamic_dir, "/", dirp->d_name, NULL));
+            unlink(apr_pstrcat(tp, fcgi_dynamic_dir, "/", dirp->d_name, NULL));
         }
     }
 
 #endif /* !APACHE2 */
 
-    ap_destroy_pool(tp);
+    apr_destroy_pool(tp);
 
     return NULL;
 }
@@ -498,7 +498,7 @@
     fcgi_socket_dir = arg_nc;
 
 #ifdef WIN32
-    fcgi_dynamic_dir = ap_pstrcat(cmd->pool, fcgi_socket_dir, "dynamic", NULL);
+    fcgi_dynamic_dir = apr_pstrcat(cmd->pool, fcgi_socket_dir, "dynamic", NULL);
 #else
     err = fcgi_config_make_dir(tp, fcgi_socket_dir);
     if (err != NULL)
@@ -853,7 +853,7 @@
     }
 
     if (!*fs_path) {
-        return ap_pstrcat(tp, name, " requires a path and either a -socket or -host option", NULL);
+        return apr_pstrcat(tp, name, " requires a path and either a -socket or -host option", NULL);
     }
 
 #ifdef APACHE2
diff -urN mod_fastcgi-2.4.2.org/fcgi_pm.c mod_fastcgi-2.4.2/fcgi_pm.c
--- mod_fastcgi-2.4.2.org/fcgi_pm.c	2004-10-06 20:30:46.337894116 +0200
+++ mod_fastcgi-2.4.2/fcgi_pm.c	2004-10-06 21:33:50.371253714 +0200
@@ -576,7 +576,7 @@
         fs->envp[i - 1] = NULL;
     }
 
-    ap_destroy_pool(tp);
+    apr_destroy_pool(tp);
 
     return proc.pid;
 
@@ -659,7 +659,7 @@
             "FastCGI: %s is not executable; ensure interpreted scripts have "
             "\"#!\" as their first line", 
             fs->fs_path);
-        ap_destroy_pool(tp);
+        apr_destroy_pool(tp);
         goto CLEANUP;
     }
 
@@ -668,9 +668,9 @@
      * the arguments (if there are any).
      * Build the command string to pass to CreateProcess. 
      */
-    quoted_filename = ap_pstrcat(tp, "\"", fs->fs_path, "\"", NULL);
+    quoted_filename = apr_pstrcat(tp, "\"", fs->fs_path, "\"", NULL);
     if (interpreter && *interpreter) {
-        pCommand = ap_pstrcat(tp, interpreter, " ", quoted_filename, NULL);
+        pCommand = apr_pstrcat(tp, interpreter, " ", quoted_filename, NULL);
     }
     else {
         pCommand = quoted_filename;
@@ -744,7 +744,7 @@
         CloseHandle(listen_handle);
     }
 
-    ap_destroy_pool(tp);
+    apr_destroy_pool(tp);
 
     return pid;
 
@@ -1340,7 +1340,7 @@
         continue;
 
 BagNewServer:
-        if (sp) ap_destroy_pool(sp);
+        if (sp) apr_destroy_pool(sp);
 
 #ifdef WIN32
     free(cjob->fs_path);
@@ -1362,7 +1362,7 @@
     }
 #endif
 
-    ap_destroy_pool(tp);
+    apr_destroy_pool(tp);
 }
 
 /*
diff -urN mod_fastcgi-2.4.2.org/fcgi_protocol.c mod_fastcgi-2.4.2/fcgi_protocol.c
--- mod_fastcgi-2.4.2.org/fcgi_protocol.c	2004-10-06 20:30:46.338893902 +0200
+++ mod_fastcgi-2.4.2/fcgi_protocol.c	2004-10-06 21:33:50.374253072 +0200
@@ -135,18 +135,18 @@
 {
     table *e = r->subprocess_env;
 
-    ap_table_setn(e, "GATEWAY_INTERFACE", "CGI/1.1");
-    ap_table_setn(e, "SERVER_PROTOCOL", r->protocol);
-    ap_table_setn(e, "REQUEST_METHOD", r->method);
-    ap_table_setn(e, "QUERY_STRING", r->args ? r->args : "");
-    ap_table_setn(e, "REQUEST_URI", apache_original_uri(r));
+    apr_table_setn(e, "GATEWAY_INTERFACE", "CGI/1.1");
+    apr_table_setn(e, "SERVER_PROTOCOL", r->protocol);
+    apr_table_setn(e, "REQUEST_METHOD", r->method);
+    apr_table_setn(e, "QUERY_STRING", r->args ? r->args : "");
+    apr_table_setn(e, "REQUEST_URI", apache_original_uri(r));
 
     /* The FastCGI spec precludes sending of CONTENT_LENGTH, PATH_INFO,
      * PATH_TRANSLATED, and SCRIPT_NAME (for some reason?).  PATH_TRANSLATED we
      * don't have, its the variable that causes Apache to break trying to set
      * up (and thus the reason this fn exists vs. using ap_add_cgi_vars()). */
     if (compat) {
-        ap_table_unset(e, "CONTENT_LENGTH");
+        apr_table_unset(e, "CONTENT_LENGTH");
         return;
     }
 
@@ -155,17 +155,17 @@
      * args and path_info of the original request, and not any that may have
      * come with the script URI in the include command.  Ugh. */
     if (!strcmp(r->protocol, "INCLUDED")) {
-        ap_table_setn(e, "SCRIPT_NAME", r->uri);
+        apr_table_setn(e, "SCRIPT_NAME", r->uri);
         if (r->path_info && *r->path_info)
-            ap_table_setn(e, "PATH_INFO", r->path_info);
+            apr_table_setn(e, "PATH_INFO", r->path_info);
     }
     else if (!r->path_info || !*r->path_info)
-        ap_table_setn(e, "SCRIPT_NAME", r->uri);
+        apr_table_setn(e, "SCRIPT_NAME", r->uri);
     else {
         int path_info_start = ap_find_path_info(r->uri, r->path_info);
 
-        ap_table_setn(e, "SCRIPT_NAME", ap_pstrndup(r->pool, r->uri, path_info_start));
-        ap_table_setn(e, "PATH_INFO", r->path_info);
+        apr_table_setn(e, "SCRIPT_NAME", ap_pstrndup(r->pool, r->uri, path_info_start));
+        apr_table_setn(e, "PATH_INFO", r->path_info);
     }
 }
 
@@ -178,9 +178,9 @@
         int i = ph->nelts;
 
         for ( ; i; --i, ++elt) {
-            const char *val = ap_table_get(fr->r->headers_in, *elt);
+            const char *val = apr_table_get(fr->r->headers_in, *elt);
             if (val) {
-                ap_table_setn(fr->r->subprocess_env, *elt, val);
+                apr_table_setn(fr->r->subprocess_env, *elt, val);
             }
         }
     }
@@ -373,7 +373,7 @@
 
                 if (fr->fs_stderr == NULL)
                 {
-                    fr->fs_stderr = ap_palloc(p, FCGI_SERVER_MAX_STDERR_LINE_LEN + 1);
+                    fr->fs_stderr = apr_palloc(p, FCGI_SERVER_MAX_STDERR_LINE_LEN + 1);
                 }
 
                 /* We're gonna consume all thats here */
diff -urN mod_fastcgi-2.4.2.org/fcgi_util.c mod_fastcgi-2.4.2/fcgi_util.c
--- mod_fastcgi-2.4.2.org/fcgi_util.c	2004-10-06 20:30:46.339893687 +0200
+++ mod_fastcgi-2.4.2/fcgi_util.c	2004-10-06 21:33:50.378252215 +0200
@@ -55,7 +55,7 @@
 fcgi_util_socket_hash_filename(pool *p, const char *path,
         const char *user, const char *group)
 {
-    char *buf = ap_pstrcat(p, path, user, group, NULL);
+    char *buf = apr_pstrcat(p, path, user, group, NULL);
 
     /* Canonicalize the path (remove "//", ".", "..") */
     ap_getparents(buf);
@@ -77,13 +77,13 @@
     x = strlen(src1);
 
     if (x == 0) {
-	    p = ap_pstrcat(a, "\\", src2, NULL);
+	    p = apr_pstrcat(a, "\\", src2, NULL);
     }
     else if (src1[x - 1] != '\\' && src1[x - 1] != '/') {
-	    p = ap_pstrcat(a, src1, "\\", src2, NULL);
+	    p = apr_pstrcat(a, src1, "\\", src2, NULL);
     }
     else {
-	    p = ap_pstrcat(a, src1, src2, NULL);
+	    p = apr_pstrcat(a, src1, src2, NULL);
     }
 
     q = p ;
@@ -137,7 +137,7 @@
     int socket_pathLen = strlen(socket_path);
 
     if (socket_pathLen >= sizeof((*socket_addr)->sun_path)) {
-        return ap_pstrcat(p, "path \"", socket_path,
+        return apr_pstrcat(p, "path \"", socket_path,
                        "\" is too long for a Domain socket", NULL);
     }
 
@@ -204,7 +204,7 @@
     /* Get an in_addr represention of the host */
     if (host != NULL) {
         if (convert_string_to_in_addr(host, &(*socket_addr)->sin_addr) != 1) {
-            return ap_pstrcat(p, "failed to resolve \"", host,
+            return apr_pstrcat(p, "failed to resolve \"", host,
                            "\" to exactly one IP address", NULL);
         }
     } else {
@@ -311,7 +311,7 @@
     fcgi_server *s;
 
     /* @@@ This should now be done in the loop below */
-    ap_cpystrn(path, ePath, FCGI_MAXPATH);
+    apr_cpystrn(path, ePath, FCGI_MAXPATH);
     ap_no2slash(path);
 
     for (s = fcgi_servers; s != NULL; s = s->next) {
@@ -343,7 +343,7 @@
     char path[FCGI_MAXPATH];
     fcgi_server *s;
 
-    ap_cpystrn(path, ePath, FCGI_MAXPATH);
+    apr_cpystrn(path, ePath, FCGI_MAXPATH);
     ap_no2slash(path);
     
     for (s = fcgi_servers; s != NULL; s = s->next) {
@@ -367,7 +367,7 @@
     const char *err;
 
     if (finfo == NULL) {
-        finfo = (struct stat *)ap_palloc(p, sizeof(struct stat));	        
+        finfo = (struct stat *)apr_palloc(p, sizeof(struct stat));	        
         if (stat(fs_path, finfo) < 0)
             return ap_psprintf(p, "stat(%s) failed: %s", fs_path, strerror(errno));
     }
diff -urN mod_fastcgi-2.4.2.org/mod_fastcgi.c mod_fastcgi-2.4.2/mod_fastcgi.c
--- mod_fastcgi-2.4.2.org/mod_fastcgi.c	2004-10-06 20:30:46.355890260 +0200
+++ mod_fastcgi-2.4.2/mod_fastcgi.c	2004-10-06 21:33:50.392249217 +0200
@@ -267,7 +267,7 @@
 
     /* Register to reset to default values when the config pool is cleaned */
     ap_block_alarms();
-    ap_register_cleanup(p, NULL, fcgi_config_reset_globals, ap_null_cleanup);
+    ap_register_cleanup(p, NULL, fcgi_config_reset_globals, apr_pool_cleanup_null);
     ap_unblock_alarms();
 
 #ifdef APACHE2
@@ -285,7 +285,7 @@
 #ifdef WIN32
     if (fcgi_socket_dir == NULL)
         fcgi_socket_dir = DEFAULT_SOCK_DIR;
-    fcgi_dynamic_dir = ap_pstrcat(p, fcgi_socket_dir, "dynamic", NULL);
+    fcgi_dynamic_dir = apr_pstrcat(p, fcgi_socket_dir, "dynamic", NULL);
 #else
 
     if (fcgi_socket_dir == NULL)
@@ -765,7 +765,7 @@
      * Who responds, this handler or Apache?
      */
     if (hasLocation) {
-        const char *location = ap_table_get(r->headers_out, "Location");
+        const char *location = apr_table_get(r->headers_out, "Location");
         /*
          * Based on internal redirect handling in mod_cgi.c...
          *
@@ -2318,7 +2318,7 @@
     }
 
     ap_block_alarms();
-    ap_register_cleanup(rp, (void *)fr, cleanup, ap_null_cleanup);
+    ap_register_cleanup(rp, (void *)fr, cleanup, apr_pool_cleanup_null);
     ap_unblock_alarms();
 
 #ifdef WIN32
@@ -2450,7 +2450,7 @@
         else
 #endif
         {
-            my_finfo = (struct stat *) ap_palloc(p, sizeof(struct stat));
+            my_finfo = (struct stat *) apr_palloc(p, sizeof(struct stat));
             
             if (stat(fs_path, my_finfo) < 0) 
             {
@@ -2476,7 +2476,7 @@
     fr->erBufPtr = fcgi_buf_new(p, sizeof(FCGI_EndRequestBody) + 1);
     fr->gotHeader = FALSE;
     fr->parseHeader = SCAN_CGI_READING_HEADERS;
-    fr->header = ap_make_array(p, 1, 1);
+    fr->header = apr_array_make(p, 1, 1);
     fr->fs_stderr = NULL;
     fr->r = r;
     fr->readingEndRequestBody = FALSE;
@@ -2531,7 +2531,7 @@
  */
 static int apache_is_scriptaliased(request_rec *r)
 {
-    const char *t = ap_table_get(r->notes, "alias-forced-type");
+    const char *t = apr_table_get(r->notes, "alias-forced-type");
     return t && (!strcasecmp(t, "cgi-script"));
 }
 
@@ -2554,9 +2554,9 @@
              */
             r->method = "GET";
             r->method_number = M_GET;
-            ap_table_unset(r->headers_in, "Content-length");
+            apr_table_unset(r->headers_in, "Content-length");
 
-            ap_internal_redirect_handler(ap_table_get(r->headers_out, "Location"), r);
+            ap_internal_redirect_handler(apr_table_get(r->headers_out, "Location"), r);
             return OK;
 
         case SCAN_CGI_SRV_REDIRECT:
@@ -2612,21 +2612,21 @@
     if (strncasecmp(key, "Variable-", 9) == 0)
         key += 9;
 
-    ap_table_setn(t, key, val);
+    apr_table_setn(t, key, val);
     return 1;
 }
 
 static int post_process_auth_passed_compat_header(table *t, const char *key, const char * const val)
 {
     if (strncasecmp(key, "Variable-", 9) == 0)
-        ap_table_setn(t, key + 9, val);
+        apr_table_setn(t, key + 9, val);
 
     return 1;
 }
 
 static int post_process_auth_failed_header(table * const t, const char * const key, const char * const val)
 {
-    ap_table_setn(t, key, val);
+    apr_table_setn(t, key, val);
     return 1;
 }
 
@@ -2639,16 +2639,16 @@
 
     if (passed) {
         if (fr->auth_compat) {
-            ap_table_do((int (*)(void *, const char *, const char *))post_process_auth_passed_compat_header,
+            apr_table_do((int (*)(void *, const char *, const char *))post_process_auth_passed_compat_header,
                  (void *)r->subprocess_env, fr->authHeaders, NULL);
         }
         else {
-            ap_table_do((int (*)(void *, const char *, const char *))post_process_auth_passed_header,
+            apr_table_do((int (*)(void *, const char *, const char *))post_process_auth_passed_header,
                  (void *)r->subprocess_env, fr->authHeaders, NULL);
         }
     }
     else {
-        ap_table_do((int (*)(void *, const char *, const char *))post_process_auth_failed_header,
+        apr_table_do((int (*)(void *, const char *, const char *))post_process_auth_failed_header,
              (void *)r->err_headers_out, fr->authHeaders, NULL);
     }
 
@@ -2681,8 +2681,8 @@
     /* Save the existing subprocess_env, because we're gonna muddy it up */
     fr->saved_subprocess_env = ap_copy_table(r->pool, r->subprocess_env);
 
-    ap_table_setn(r->subprocess_env, "REMOTE_PASSWD", password);
-    ap_table_setn(r->subprocess_env, "FCGI_APACHE_ROLE", "AUTHENTICATOR");
+    apr_table_setn(r->subprocess_env, "REMOTE_PASSWD", password);
+    apr_table_setn(r->subprocess_env, "FCGI_APACHE_ROLE", "AUTHENTICATOR");
 
     /* The FastCGI Protocol doesn't differentiate authentication */
     fr->role = FCGI_AUTHORIZER;
@@ -2697,7 +2697,7 @@
     post_process_auth(fr, authenticated);
 
     /* A redirect shouldn't be allowed during the authentication phase */
-    if (ap_table_get(r->headers_out, "Location") != NULL) {
+    if (apr_table_get(r->headers_out, "Location") != NULL) {
         ap_log_rerror(FCGI_LOG_ERR_NOERRNO, r,
             "FastCGI: FastCgiAuthenticator \"%s\" redirected (not allowed)",
             dir_config->authenticator);
@@ -2748,7 +2748,7 @@
     /* Save the existing subprocess_env, because we're gonna muddy it up */
     fr->saved_subprocess_env = ap_copy_table(r->pool, r->subprocess_env);
 
-    ap_table_setn(r->subprocess_env, "FCGI_APACHE_ROLE", "AUTHORIZER");
+    apr_table_setn(r->subprocess_env, "FCGI_APACHE_ROLE", "AUTHORIZER");
 
     fr->role = FCGI_AUTHORIZER;
 
@@ -2762,7 +2762,7 @@
     post_process_auth(fr, authorized);
 
     /* A redirect shouldn't be allowed during the authorization phase */
-    if (ap_table_get(r->headers_out, "Location") != NULL) {
+    if (apr_table_get(r->headers_out, "Location") != NULL) {
         ap_log_rerror(FCGI_LOG_ERR_NOERRNO, r,
             "FastCGI: FastCgiAuthorizer \"%s\" redirected (not allowed)",
             dir_config->authorizer);
@@ -2808,7 +2808,7 @@
     /* Save the existing subprocess_env, because we're gonna muddy it up */
     fr->saved_subprocess_env = ap_copy_table(r->pool, r->subprocess_env);
 
-    ap_table_setn(r->subprocess_env, "FCGI_APACHE_ROLE", "ACCESS_CHECKER");
+    apr_table_setn(r->subprocess_env, "FCGI_APACHE_ROLE", "ACCESS_CHECKER");
 
     /* The FastCGI Protocol doesn't differentiate access control */
     fr->role = FCGI_AUTHORIZER;
@@ -2823,7 +2823,7 @@
     post_process_auth(fr, access_allowed);
 
     /* A redirect shouldn't be allowed during the access check phase */
-    if (ap_table_get(r->headers_out, "Location") != NULL) {
+    if (apr_table_get(r->headers_out, "Location") != NULL) {
         ap_log_rerror(FCGI_LOG_ERR_NOERRNO, r,
             "FastCGI: FastCgiAccessChecker \"%s\" redirected (not allowed)",
             dir_config->access_checker);
